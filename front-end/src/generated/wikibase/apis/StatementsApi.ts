/* tslint:disable */
/* eslint-disable */
/**
 * Wikibase REST API
 * OpenAPI definition of Wikibase REST API
 *
 * The version of the OpenAPI document: 0.4
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  AddItemStatementRequest,
  EditSchema,
  ItemNotFoundSchema,
  Statement,
  StatementPatchSchema,
} from '../models/index';
import {
    AddItemStatementRequestFromJSON,
    AddItemStatementRequestToJSON,
    EditSchemaFromJSON,
    EditSchemaToJSON,
    ItemNotFoundSchemaFromJSON,
    ItemNotFoundSchemaToJSON,
    StatementFromJSON,
    StatementToJSON,
    StatementPatchSchemaFromJSON,
    StatementPatchSchemaToJSON,
} from '../models/index';

export interface AddItemStatementOperationRequest {
    itemId: string;
    addItemStatementRequest: AddItemStatementRequest;
    ifMatch?: Array<string>;
    ifUnmodifiedSince?: string;
    ifNoneMatch?: Array<string>;
}

export interface AddPropertyStatementRequest {
    propertyId: string;
    addItemStatementRequest: AddItemStatementRequest;
    ifMatch?: Array<string>;
    ifUnmodifiedSince?: string;
    ifNoneMatch?: Array<string>;
}

export interface DeleteItemStatementRequest {
    itemId: string;
    statementId: string;
    ifMatch?: Array<string>;
    ifNoneMatch?: Array<string>;
    ifUnmodifiedSince?: string;
    editSchema?: EditSchema;
}

export interface DeletePropertyStatementRequest {
    propertyId: string;
    statementId: string;
    ifMatch?: Array<string>;
    ifNoneMatch?: Array<string>;
    ifUnmodifiedSince?: string;
    editSchema?: EditSchema;
}

export interface DeleteStatementRequest {
    statementId: string;
    ifMatch?: Array<string>;
    ifNoneMatch?: Array<string>;
    ifUnmodifiedSince?: string;
    editSchema?: EditSchema;
}

export interface GetItemStatementRequest {
    itemId: string;
    statementId: string;
    ifNoneMatch?: Array<string>;
    ifModifiedSince?: string;
    ifMatch?: Array<string>;
    ifUnmodifiedSince?: string;
    authorization?: string;
}

export interface GetItemStatementsRequest {
    itemId: string;
    property?: string;
    ifNoneMatch?: Array<string>;
    ifModifiedSince?: string;
    ifMatch?: Array<string>;
    ifUnmodifiedSince?: string;
    authorization?: string;
}

export interface GetPropertyStatementRequest {
    propertyId: string;
    statementId: string;
    ifNoneMatch?: Array<string>;
    ifModifiedSince?: string;
    ifMatch?: Array<string>;
    ifUnmodifiedSince?: string;
    authorization?: string;
}

export interface GetPropertyStatementsRequest {
    propertyId: string;
    property?: string;
    ifNoneMatch?: Array<string>;
    ifModifiedSince?: string;
    ifMatch?: Array<string>;
    ifUnmodifiedSince?: string;
    authorization?: string;
}

export interface GetStatementRequest {
    statementId: string;
    ifNoneMatch?: Array<string>;
    ifModifiedSince?: string;
    ifMatch?: Array<string>;
    ifUnmodifiedSince?: string;
    authorization?: string;
}

export interface PatchItemStatementRequest {
    itemId: string;
    statementId: string;
    statementPatchSchema: StatementPatchSchema;
    ifMatch?: Array<string>;
    ifNoneMatch?: Array<string>;
    ifUnmodifiedSince?: string;
}

export interface PatchPropertyStatementRequest {
    propertyId: string;
    statementId: string;
    statementPatchSchema: StatementPatchSchema;
    ifMatch?: Array<string>;
    ifNoneMatch?: Array<string>;
    ifUnmodifiedSince?: string;
}

export interface PatchStatementRequest {
    statementId: string;
    statementPatchSchema: StatementPatchSchema;
    ifMatch?: Array<string>;
    ifNoneMatch?: Array<string>;
    ifUnmodifiedSince?: string;
}

export interface ReplaceItemStatementRequest {
    itemId: string;
    statementId: string;
    addItemStatementRequest: AddItemStatementRequest;
    ifMatch?: Array<string>;
    ifNoneMatch?: Array<string>;
    ifUnmodifiedSince?: string;
}

export interface ReplacePropertyStatementRequest {
    propertyId: string;
    statementId: string;
    addItemStatementRequest: AddItemStatementRequest;
    ifMatch?: Array<string>;
    ifNoneMatch?: Array<string>;
    ifUnmodifiedSince?: string;
}

export interface ReplaceStatementRequest {
    statementId: string;
    addItemStatementRequest: AddItemStatementRequest;
    ifMatch?: Array<string>;
    ifNoneMatch?: Array<string>;
    ifUnmodifiedSince?: string;
}

/**
 * 
 */
export class StatementsApi extends runtime.BaseAPI {

    /**
     * Add a new Statement to an Item
     */
    async addItemStatementRaw(requestParameters: AddItemStatementOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Statement>> {
        if (requestParameters['itemId'] == null) {
            throw new runtime.RequiredError(
                'itemId',
                'Required parameter "itemId" was null or undefined when calling addItemStatement().'
            );
        }

        if (requestParameters['addItemStatementRequest'] == null) {
            throw new runtime.RequiredError(
                'addItemStatementRequest',
                'Required parameter "addItemStatementRequest" was null or undefined when calling addItemStatement().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters['ifMatch'] != null) {
            headerParameters['If-Match'] = requestParameters['ifMatch']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters['ifUnmodifiedSince'] != null) {
            headerParameters['If-Unmodified-Since'] = String(requestParameters['ifUnmodifiedSince']);
        }

        if (requestParameters['ifNoneMatch'] != null) {
            headerParameters['If-None-Match'] = requestParameters['ifNoneMatch']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const response = await this.request({
            path: `/entities/items/{item_id}/statements`.replace(`{${"item_id"}}`, encodeURIComponent(String(requestParameters['itemId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: AddItemStatementRequestToJSON(requestParameters['addItemStatementRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatementFromJSON(jsonValue));
    }

    /**
     * Add a new Statement to an Item
     */
    async addItemStatement(requestParameters: AddItemStatementOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Statement> {
        const response = await this.addItemStatementRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Add a new Statement to a Property
     */
    async addPropertyStatementRaw(requestParameters: AddPropertyStatementRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Statement>> {
        if (requestParameters['propertyId'] == null) {
            throw new runtime.RequiredError(
                'propertyId',
                'Required parameter "propertyId" was null or undefined when calling addPropertyStatement().'
            );
        }

        if (requestParameters['addItemStatementRequest'] == null) {
            throw new runtime.RequiredError(
                'addItemStatementRequest',
                'Required parameter "addItemStatementRequest" was null or undefined when calling addPropertyStatement().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters['ifMatch'] != null) {
            headerParameters['If-Match'] = requestParameters['ifMatch']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters['ifUnmodifiedSince'] != null) {
            headerParameters['If-Unmodified-Since'] = String(requestParameters['ifUnmodifiedSince']);
        }

        if (requestParameters['ifNoneMatch'] != null) {
            headerParameters['If-None-Match'] = requestParameters['ifNoneMatch']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const response = await this.request({
            path: `/entities/properties/{property_id}/statements`.replace(`{${"property_id"}}`, encodeURIComponent(String(requestParameters['propertyId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: AddItemStatementRequestToJSON(requestParameters['addItemStatementRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatementFromJSON(jsonValue));
    }

    /**
     * Add a new Statement to a Property
     */
    async addPropertyStatement(requestParameters: AddPropertyStatementRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Statement> {
        const response = await this.addPropertyStatementRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This endpoint is also accessible through `/statements/{statement_id}`
     * Delete a single Statement from an Item
     */
    async deleteItemStatementRaw(requestParameters: DeleteItemStatementRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['itemId'] == null) {
            throw new runtime.RequiredError(
                'itemId',
                'Required parameter "itemId" was null or undefined when calling deleteItemStatement().'
            );
        }

        if (requestParameters['statementId'] == null) {
            throw new runtime.RequiredError(
                'statementId',
                'Required parameter "statementId" was null or undefined when calling deleteItemStatement().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters['ifMatch'] != null) {
            headerParameters['If-Match'] = requestParameters['ifMatch']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters['ifNoneMatch'] != null) {
            headerParameters['If-None-Match'] = requestParameters['ifNoneMatch']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters['ifUnmodifiedSince'] != null) {
            headerParameters['If-Unmodified-Since'] = String(requestParameters['ifUnmodifiedSince']);
        }

        const response = await this.request({
            path: `/entities/items/{item_id}/statements/{statement_id}`.replace(`{${"item_id"}}`, encodeURIComponent(String(requestParameters['itemId']))).replace(`{${"statement_id"}}`, encodeURIComponent(String(requestParameters['statementId']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: EditSchemaToJSON(requestParameters['editSchema']),
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * This endpoint is also accessible through `/statements/{statement_id}`
     * Delete a single Statement from an Item
     */
    async deleteItemStatement(requestParameters: DeleteItemStatementRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.deleteItemStatementRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This endpoint is also accessible through `/statements/{statement_id}`.
     * Delete a single Statement from a Property
     */
    async deletePropertyStatementRaw(requestParameters: DeletePropertyStatementRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['propertyId'] == null) {
            throw new runtime.RequiredError(
                'propertyId',
                'Required parameter "propertyId" was null or undefined when calling deletePropertyStatement().'
            );
        }

        if (requestParameters['statementId'] == null) {
            throw new runtime.RequiredError(
                'statementId',
                'Required parameter "statementId" was null or undefined when calling deletePropertyStatement().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters['ifMatch'] != null) {
            headerParameters['If-Match'] = requestParameters['ifMatch']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters['ifNoneMatch'] != null) {
            headerParameters['If-None-Match'] = requestParameters['ifNoneMatch']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters['ifUnmodifiedSince'] != null) {
            headerParameters['If-Unmodified-Since'] = String(requestParameters['ifUnmodifiedSince']);
        }

        const response = await this.request({
            path: `/entities/properties/{property_id}/statements/{statement_id}`.replace(`{${"property_id"}}`, encodeURIComponent(String(requestParameters['propertyId']))).replace(`{${"statement_id"}}`, encodeURIComponent(String(requestParameters['statementId']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: EditSchemaToJSON(requestParameters['editSchema']),
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * This endpoint is also accessible through `/statements/{statement_id}`.
     * Delete a single Statement from a Property
     */
    async deletePropertyStatement(requestParameters: DeletePropertyStatementRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.deletePropertyStatementRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This endpoint is also accessible through `/entities/items/{item_id}/statements/{statement_id}` and `/entities/properties/{property_id}/statements/{statement_id}`
     * Delete a single Statement
     */
    async deleteStatementRaw(requestParameters: DeleteStatementRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['statementId'] == null) {
            throw new runtime.RequiredError(
                'statementId',
                'Required parameter "statementId" was null or undefined when calling deleteStatement().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters['ifMatch'] != null) {
            headerParameters['If-Match'] = requestParameters['ifMatch']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters['ifNoneMatch'] != null) {
            headerParameters['If-None-Match'] = requestParameters['ifNoneMatch']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters['ifUnmodifiedSince'] != null) {
            headerParameters['If-Unmodified-Since'] = String(requestParameters['ifUnmodifiedSince']);
        }

        const response = await this.request({
            path: `/statements/{statement_id}`.replace(`{${"statement_id"}}`, encodeURIComponent(String(requestParameters['statementId']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: EditSchemaToJSON(requestParameters['editSchema']),
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * This endpoint is also accessible through `/entities/items/{item_id}/statements/{statement_id}` and `/entities/properties/{property_id}/statements/{statement_id}`
     * Delete a single Statement
     */
    async deleteStatement(requestParameters: DeleteStatementRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.deleteStatementRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This endpoint is also accessible through `/statements/{statement_id}`
     * Retrieve a single Statement from an Item
     */
    async getItemStatementRaw(requestParameters: GetItemStatementRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Statement>> {
        if (requestParameters['itemId'] == null) {
            throw new runtime.RequiredError(
                'itemId',
                'Required parameter "itemId" was null or undefined when calling getItemStatement().'
            );
        }

        if (requestParameters['statementId'] == null) {
            throw new runtime.RequiredError(
                'statementId',
                'Required parameter "statementId" was null or undefined when calling getItemStatement().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['ifNoneMatch'] != null) {
            headerParameters['If-None-Match'] = requestParameters['ifNoneMatch']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters['ifModifiedSince'] != null) {
            headerParameters['If-Modified-Since'] = String(requestParameters['ifModifiedSince']);
        }

        if (requestParameters['ifMatch'] != null) {
            headerParameters['If-Match'] = requestParameters['ifMatch']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters['ifUnmodifiedSince'] != null) {
            headerParameters['If-Unmodified-Since'] = String(requestParameters['ifUnmodifiedSince']);
        }

        if (requestParameters['authorization'] != null) {
            headerParameters['Authorization'] = String(requestParameters['authorization']);
        }

        const response = await this.request({
            path: `/entities/items/{item_id}/statements/{statement_id}`.replace(`{${"item_id"}}`, encodeURIComponent(String(requestParameters['itemId']))).replace(`{${"statement_id"}}`, encodeURIComponent(String(requestParameters['statementId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatementFromJSON(jsonValue));
    }

    /**
     * This endpoint is also accessible through `/statements/{statement_id}`
     * Retrieve a single Statement from an Item
     */
    async getItemStatement(requestParameters: GetItemStatementRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Statement> {
        const response = await this.getItemStatementRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve Statements from an Item
     */
    async getItemStatementsRaw(requestParameters: GetItemStatementsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<{ [key: string]: Array<Statement>; }>> {
        if (requestParameters['itemId'] == null) {
            throw new runtime.RequiredError(
                'itemId',
                'Required parameter "itemId" was null or undefined when calling getItemStatements().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['property'] != null) {
            queryParameters['property'] = requestParameters['property'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['ifNoneMatch'] != null) {
            headerParameters['If-None-Match'] = requestParameters['ifNoneMatch']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters['ifModifiedSince'] != null) {
            headerParameters['If-Modified-Since'] = String(requestParameters['ifModifiedSince']);
        }

        if (requestParameters['ifMatch'] != null) {
            headerParameters['If-Match'] = requestParameters['ifMatch']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters['ifUnmodifiedSince'] != null) {
            headerParameters['If-Unmodified-Since'] = String(requestParameters['ifUnmodifiedSince']);
        }

        if (requestParameters['authorization'] != null) {
            headerParameters['Authorization'] = String(requestParameters['authorization']);
        }

        const response = await this.request({
            path: `/entities/items/{item_id}/statements`.replace(`{${"item_id"}}`, encodeURIComponent(String(requestParameters['itemId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Retrieve Statements from an Item
     */
    async getItemStatements(requestParameters: GetItemStatementsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<{ [key: string]: Array<Statement>; }> {
        const response = await this.getItemStatementsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This endpoint is also accessible through `/statements/{statement_id}`
     * Retrieve a single Statement from a Property
     */
    async getPropertyStatementRaw(requestParameters: GetPropertyStatementRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Statement>> {
        if (requestParameters['propertyId'] == null) {
            throw new runtime.RequiredError(
                'propertyId',
                'Required parameter "propertyId" was null or undefined when calling getPropertyStatement().'
            );
        }

        if (requestParameters['statementId'] == null) {
            throw new runtime.RequiredError(
                'statementId',
                'Required parameter "statementId" was null or undefined when calling getPropertyStatement().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['ifNoneMatch'] != null) {
            headerParameters['If-None-Match'] = requestParameters['ifNoneMatch']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters['ifModifiedSince'] != null) {
            headerParameters['If-Modified-Since'] = String(requestParameters['ifModifiedSince']);
        }

        if (requestParameters['ifMatch'] != null) {
            headerParameters['If-Match'] = requestParameters['ifMatch']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters['ifUnmodifiedSince'] != null) {
            headerParameters['If-Unmodified-Since'] = String(requestParameters['ifUnmodifiedSince']);
        }

        if (requestParameters['authorization'] != null) {
            headerParameters['Authorization'] = String(requestParameters['authorization']);
        }

        const response = await this.request({
            path: `/entities/properties/{property_id}/statements/{statement_id}`.replace(`{${"property_id"}}`, encodeURIComponent(String(requestParameters['propertyId']))).replace(`{${"statement_id"}}`, encodeURIComponent(String(requestParameters['statementId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatementFromJSON(jsonValue));
    }

    /**
     * This endpoint is also accessible through `/statements/{statement_id}`
     * Retrieve a single Statement from a Property
     */
    async getPropertyStatement(requestParameters: GetPropertyStatementRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Statement> {
        const response = await this.getPropertyStatementRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve Statements from a Property
     */
    async getPropertyStatementsRaw(requestParameters: GetPropertyStatementsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<{ [key: string]: Array<Statement>; }>> {
        if (requestParameters['propertyId'] == null) {
            throw new runtime.RequiredError(
                'propertyId',
                'Required parameter "propertyId" was null or undefined when calling getPropertyStatements().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['property'] != null) {
            queryParameters['property'] = requestParameters['property'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['ifNoneMatch'] != null) {
            headerParameters['If-None-Match'] = requestParameters['ifNoneMatch']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters['ifModifiedSince'] != null) {
            headerParameters['If-Modified-Since'] = String(requestParameters['ifModifiedSince']);
        }

        if (requestParameters['ifMatch'] != null) {
            headerParameters['If-Match'] = requestParameters['ifMatch']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters['ifUnmodifiedSince'] != null) {
            headerParameters['If-Unmodified-Since'] = String(requestParameters['ifUnmodifiedSince']);
        }

        if (requestParameters['authorization'] != null) {
            headerParameters['Authorization'] = String(requestParameters['authorization']);
        }

        const response = await this.request({
            path: `/entities/properties/{property_id}/statements`.replace(`{${"property_id"}}`, encodeURIComponent(String(requestParameters['propertyId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Retrieve Statements from a Property
     */
    async getPropertyStatements(requestParameters: GetPropertyStatementsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<{ [key: string]: Array<Statement>; }> {
        const response = await this.getPropertyStatementsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This endpoint is also accessible through `/entities/items/{item_id}/statements/{statement_id}` and `/entities/properties/{property_id}/statements/{statement_id}`
     * Retrieve a single Statement
     */
    async getStatementRaw(requestParameters: GetStatementRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Statement>> {
        if (requestParameters['statementId'] == null) {
            throw new runtime.RequiredError(
                'statementId',
                'Required parameter "statementId" was null or undefined when calling getStatement().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['ifNoneMatch'] != null) {
            headerParameters['If-None-Match'] = requestParameters['ifNoneMatch']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters['ifModifiedSince'] != null) {
            headerParameters['If-Modified-Since'] = String(requestParameters['ifModifiedSince']);
        }

        if (requestParameters['ifMatch'] != null) {
            headerParameters['If-Match'] = requestParameters['ifMatch']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters['ifUnmodifiedSince'] != null) {
            headerParameters['If-Unmodified-Since'] = String(requestParameters['ifUnmodifiedSince']);
        }

        if (requestParameters['authorization'] != null) {
            headerParameters['Authorization'] = String(requestParameters['authorization']);
        }

        const response = await this.request({
            path: `/statements/{statement_id}`.replace(`{${"statement_id"}}`, encodeURIComponent(String(requestParameters['statementId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatementFromJSON(jsonValue));
    }

    /**
     * This endpoint is also accessible through `/entities/items/{item_id}/statements/{statement_id}` and `/entities/properties/{property_id}/statements/{statement_id}`
     * Retrieve a single Statement
     */
    async getStatement(requestParameters: GetStatementRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Statement> {
        const response = await this.getStatementRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This endpoint is also accessible through `/statements/{statement_id}`.
     * Change elements of a single Statement of an Item
     */
    async patchItemStatementRaw(requestParameters: PatchItemStatementRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Statement>> {
        if (requestParameters['itemId'] == null) {
            throw new runtime.RequiredError(
                'itemId',
                'Required parameter "itemId" was null or undefined when calling patchItemStatement().'
            );
        }

        if (requestParameters['statementId'] == null) {
            throw new runtime.RequiredError(
                'statementId',
                'Required parameter "statementId" was null or undefined when calling patchItemStatement().'
            );
        }

        if (requestParameters['statementPatchSchema'] == null) {
            throw new runtime.RequiredError(
                'statementPatchSchema',
                'Required parameter "statementPatchSchema" was null or undefined when calling patchItemStatement().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (requestParameters['ifMatch'] != null) {
            headerParameters['If-Match'] = requestParameters['ifMatch']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters['ifNoneMatch'] != null) {
            headerParameters['If-None-Match'] = requestParameters['ifNoneMatch']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters['ifUnmodifiedSince'] != null) {
            headerParameters['If-Unmodified-Since'] = String(requestParameters['ifUnmodifiedSince']);
        }

        const response = await this.request({
            path: `/entities/items/{item_id}/statements/{statement_id}`.replace(`{${"item_id"}}`, encodeURIComponent(String(requestParameters['itemId']))).replace(`{${"statement_id"}}`, encodeURIComponent(String(requestParameters['statementId']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: StatementPatchSchemaToJSON(requestParameters['statementPatchSchema']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatementFromJSON(jsonValue));
    }

    /**
     * This endpoint is also accessible through `/statements/{statement_id}`.
     * Change elements of a single Statement of an Item
     */
    async patchItemStatement(requestParameters: PatchItemStatementRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Statement> {
        const response = await this.patchItemStatementRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This endpoint is also accessible through `/statements/{statement_id}`.
     * Change elements of a single Statement of a Property
     */
    async patchPropertyStatementRaw(requestParameters: PatchPropertyStatementRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Statement>> {
        if (requestParameters['propertyId'] == null) {
            throw new runtime.RequiredError(
                'propertyId',
                'Required parameter "propertyId" was null or undefined when calling patchPropertyStatement().'
            );
        }

        if (requestParameters['statementId'] == null) {
            throw new runtime.RequiredError(
                'statementId',
                'Required parameter "statementId" was null or undefined when calling patchPropertyStatement().'
            );
        }

        if (requestParameters['statementPatchSchema'] == null) {
            throw new runtime.RequiredError(
                'statementPatchSchema',
                'Required parameter "statementPatchSchema" was null or undefined when calling patchPropertyStatement().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (requestParameters['ifMatch'] != null) {
            headerParameters['If-Match'] = requestParameters['ifMatch']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters['ifNoneMatch'] != null) {
            headerParameters['If-None-Match'] = requestParameters['ifNoneMatch']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters['ifUnmodifiedSince'] != null) {
            headerParameters['If-Unmodified-Since'] = String(requestParameters['ifUnmodifiedSince']);
        }

        const response = await this.request({
            path: `/entities/properties/{property_id}/statements/{statement_id}`.replace(`{${"property_id"}}`, encodeURIComponent(String(requestParameters['propertyId']))).replace(`{${"statement_id"}}`, encodeURIComponent(String(requestParameters['statementId']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: StatementPatchSchemaToJSON(requestParameters['statementPatchSchema']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatementFromJSON(jsonValue));
    }

    /**
     * This endpoint is also accessible through `/statements/{statement_id}`.
     * Change elements of a single Statement of a Property
     */
    async patchPropertyStatement(requestParameters: PatchPropertyStatementRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Statement> {
        const response = await this.patchPropertyStatementRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This endpoint is also accessible through `/entities/items/{item_id}/statements/{statement_id}` and `/entities/properties/{property_id}/statements/{statement_id}`
     * Change elements of a single Statement
     */
    async patchStatementRaw(requestParameters: PatchStatementRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Statement>> {
        if (requestParameters['statementId'] == null) {
            throw new runtime.RequiredError(
                'statementId',
                'Required parameter "statementId" was null or undefined when calling patchStatement().'
            );
        }

        if (requestParameters['statementPatchSchema'] == null) {
            throw new runtime.RequiredError(
                'statementPatchSchema',
                'Required parameter "statementPatchSchema" was null or undefined when calling patchStatement().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (requestParameters['ifMatch'] != null) {
            headerParameters['If-Match'] = requestParameters['ifMatch']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters['ifNoneMatch'] != null) {
            headerParameters['If-None-Match'] = requestParameters['ifNoneMatch']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters['ifUnmodifiedSince'] != null) {
            headerParameters['If-Unmodified-Since'] = String(requestParameters['ifUnmodifiedSince']);
        }

        const response = await this.request({
            path: `/statements/{statement_id}`.replace(`{${"statement_id"}}`, encodeURIComponent(String(requestParameters['statementId']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: StatementPatchSchemaToJSON(requestParameters['statementPatchSchema']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatementFromJSON(jsonValue));
    }

    /**
     * This endpoint is also accessible through `/entities/items/{item_id}/statements/{statement_id}` and `/entities/properties/{property_id}/statements/{statement_id}`
     * Change elements of a single Statement
     */
    async patchStatement(requestParameters: PatchStatementRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Statement> {
        const response = await this.patchStatementRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This endpoint is also accessible through `/statements/{statement_id}`
     * Replace a single Statement of an Item
     */
    async replaceItemStatementRaw(requestParameters: ReplaceItemStatementRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Statement>> {
        if (requestParameters['itemId'] == null) {
            throw new runtime.RequiredError(
                'itemId',
                'Required parameter "itemId" was null or undefined when calling replaceItemStatement().'
            );
        }

        if (requestParameters['statementId'] == null) {
            throw new runtime.RequiredError(
                'statementId',
                'Required parameter "statementId" was null or undefined when calling replaceItemStatement().'
            );
        }

        if (requestParameters['addItemStatementRequest'] == null) {
            throw new runtime.RequiredError(
                'addItemStatementRequest',
                'Required parameter "addItemStatementRequest" was null or undefined when calling replaceItemStatement().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters['ifMatch'] != null) {
            headerParameters['If-Match'] = requestParameters['ifMatch']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters['ifNoneMatch'] != null) {
            headerParameters['If-None-Match'] = requestParameters['ifNoneMatch']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters['ifUnmodifiedSince'] != null) {
            headerParameters['If-Unmodified-Since'] = String(requestParameters['ifUnmodifiedSince']);
        }

        const response = await this.request({
            path: `/entities/items/{item_id}/statements/{statement_id}`.replace(`{${"item_id"}}`, encodeURIComponent(String(requestParameters['itemId']))).replace(`{${"statement_id"}}`, encodeURIComponent(String(requestParameters['statementId']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: AddItemStatementRequestToJSON(requestParameters['addItemStatementRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatementFromJSON(jsonValue));
    }

    /**
     * This endpoint is also accessible through `/statements/{statement_id}`
     * Replace a single Statement of an Item
     */
    async replaceItemStatement(requestParameters: ReplaceItemStatementRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Statement> {
        const response = await this.replaceItemStatementRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This endpoint is also accessible through `/statements/{statement_id}`
     * Replace a single Statement of a Property
     */
    async replacePropertyStatementRaw(requestParameters: ReplacePropertyStatementRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Statement>> {
        if (requestParameters['propertyId'] == null) {
            throw new runtime.RequiredError(
                'propertyId',
                'Required parameter "propertyId" was null or undefined when calling replacePropertyStatement().'
            );
        }

        if (requestParameters['statementId'] == null) {
            throw new runtime.RequiredError(
                'statementId',
                'Required parameter "statementId" was null or undefined when calling replacePropertyStatement().'
            );
        }

        if (requestParameters['addItemStatementRequest'] == null) {
            throw new runtime.RequiredError(
                'addItemStatementRequest',
                'Required parameter "addItemStatementRequest" was null or undefined when calling replacePropertyStatement().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters['ifMatch'] != null) {
            headerParameters['If-Match'] = requestParameters['ifMatch']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters['ifNoneMatch'] != null) {
            headerParameters['If-None-Match'] = requestParameters['ifNoneMatch']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters['ifUnmodifiedSince'] != null) {
            headerParameters['If-Unmodified-Since'] = String(requestParameters['ifUnmodifiedSince']);
        }

        const response = await this.request({
            path: `/entities/properties/{property_id}/statements/{statement_id}`.replace(`{${"property_id"}}`, encodeURIComponent(String(requestParameters['propertyId']))).replace(`{${"statement_id"}}`, encodeURIComponent(String(requestParameters['statementId']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: AddItemStatementRequestToJSON(requestParameters['addItemStatementRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatementFromJSON(jsonValue));
    }

    /**
     * This endpoint is also accessible through `/statements/{statement_id}`
     * Replace a single Statement of a Property
     */
    async replacePropertyStatement(requestParameters: ReplacePropertyStatementRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Statement> {
        const response = await this.replacePropertyStatementRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This endpoint is also accessible through `/entities/items/{item_id}/statements/{statement_id}` and `/entities/properties/{property_id}/statements/{statement_id}`
     * Replace a single Statement
     */
    async replaceStatementRaw(requestParameters: ReplaceStatementRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Statement>> {
        if (requestParameters['statementId'] == null) {
            throw new runtime.RequiredError(
                'statementId',
                'Required parameter "statementId" was null or undefined when calling replaceStatement().'
            );
        }

        if (requestParameters['addItemStatementRequest'] == null) {
            throw new runtime.RequiredError(
                'addItemStatementRequest',
                'Required parameter "addItemStatementRequest" was null or undefined when calling replaceStatement().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters['ifMatch'] != null) {
            headerParameters['If-Match'] = requestParameters['ifMatch']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters['ifNoneMatch'] != null) {
            headerParameters['If-None-Match'] = requestParameters['ifNoneMatch']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters['ifUnmodifiedSince'] != null) {
            headerParameters['If-Unmodified-Since'] = String(requestParameters['ifUnmodifiedSince']);
        }

        const response = await this.request({
            path: `/statements/{statement_id}`.replace(`{${"statement_id"}}`, encodeURIComponent(String(requestParameters['statementId']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: AddItemStatementRequestToJSON(requestParameters['addItemStatementRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatementFromJSON(jsonValue));
    }

    /**
     * This endpoint is also accessible through `/entities/items/{item_id}/statements/{statement_id}` and `/entities/properties/{property_id}/statements/{statement_id}`
     * Replace a single Statement
     */
    async replaceStatement(requestParameters: ReplaceStatementRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Statement> {
        const response = await this.replaceStatementRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
